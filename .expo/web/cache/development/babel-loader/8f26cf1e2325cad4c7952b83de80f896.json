{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\n\nvar KeyboardManager = function (_React$Component) {\n  _inherits(KeyboardManager, _React$Component);\n\n  function KeyboardManager() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, KeyboardManager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(KeyboardManager)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.previouslyFocusedTextInput = null;\n    _this.startTimestamp = 0;\n\n    _this.clearKeyboardTimeout = function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    };\n\n    _this.handlePageChangeStart = function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = TextInput.State.currentlyFocusedField();\n      TextInput.State.blurTextInput(input);\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    };\n\n    _this.handlePageChangeConfirm = function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      Keyboard.dismiss();\n      _this.previouslyFocusedTextInput = null;\n    };\n\n    _this.handlePageChangeCancel = function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _this.previouslyFocusedTextInput;\n\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            TextInput.State.focusTextInput(input);\n            _this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          _this.previouslyFocusedTextInput = null;\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n\n  return KeyboardManager;\n}(React.Component);\n\nexport { KeyboardManager as default };","map":{"version":3,"sources":["KeyboardManager.tsx"],"names":["KeyboardManager","React","Component","previouslyFocusedTextInput","startTimestamp","clearKeyboardTimeout","clearTimeout","handlePageChangeStart","input","TextInput","Date","handlePageChangeConfirm","Keyboard","handlePageChangeCancel","setTimeout","onPageChangeStart","onPageChangeConfirm","onPageChangeCancel"],"mappings":";;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;;;;AAYqBA,IAAAA,e;;;;;;;;;;;;;;;UAOXG,0B,GAA4C,I;UAC5CC,c,GAAyB,C;;UAGzBC,oB,GAAuB,YAAM;AACnC,UAAI,KAAA,CAAA,eAAA,KAAJ,SAAA,EAAwC;AACtCC,QAAAA,YAAY,CAAC,KAAA,CAAbA,eAAY,CAAZA;AACA,QAAA,KAAA,CAAA,eAAA,GAAA,SAAA;AAEH;;;UAEOC,qB,GAAwB,YAAM;AACpC,UAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,EAAyB;AACvB;AAGF;;AAAA,MAAA,KAAA,CAAA,oBAAA;;AAEA,UAAMC,KAAK,GAAGC,SAAS,CAATA,KAAAA,CAAd,qBAAcA,EAAd;AAGAA,MAAAA,SAAS,CAATA,KAAAA,CAAAA,aAAAA,CAAAA,KAAAA;AAGA,MAAA,KAAA,CAAA,0BAAA,GAAA,KAAA;AAGA,MAAA,KAAA,CAAA,cAAA,GAAsBC,IAAI,CAA1B,GAAsBA,EAAtB;;;UAGMC,uB,GAA0B,YAAM;AACtC,UAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,EAAyB;AACvB;AAGF;;AAAA,MAAA,KAAA,CAAA,oBAAA;;AAEAC,MAAAA,QAAQ,CAARA,OAAAA;AAGA,MAAA,KAAA,CAAA,0BAAA,GAAA,IAAA;;;UAGMC,sB,GAAyB,YAAM;AACrC,UAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,EAAyB;AACvB;AAGF;;AAAA,MAAA,KAAA,CAAA,oBAAA;;AAGA,UAAML,KAAK,GAAG,KAAA,CAAd,0BAAA;;AAEA,UAAA,KAAA,EAAW;AAQT,YAAIE,IAAI,CAAJA,GAAAA,KAAa,KAAA,CAAbA,cAAAA,GAAJ,GAAA,EAA4C;AAC1C,UAAA,KAAA,CAAA,eAAA,GAAuBI,UAAU,CAAC,YAAM;AACtCL,YAAAA,SAAS,CAATA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA;AACA,YAAA,KAAA,CAAA,0BAAA,GAAA,IAAA;AAF+B,WAAA,EAAjC,GAAiC,CAAjC;AADF,SAAA,MAKO;AACLA,UAAAA,SAAS,CAATA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA;AACA,UAAA,KAAA,CAAA,0BAAA,GAAA,IAAA;AAEH;AACF;;;;;;;;2CA7EsB;AACrB,WAAA,oBAAA;;;;6BA8EO;AACP,aAAO,KAAA,KAAA,CAAA,QAAA,CAAoB;AACzBM,QAAAA,iBAAiB,EAAE,KADM,qBAAA;AAEzBC,QAAAA,mBAAmB,EAAE,KAFI,uBAAA;AAGzBC,QAAAA,kBAAkB,EAAE,KAHtB;AAA2B,OAApB,CAAP;;;;;EAjFyChB,KAAK,CAACC,S,CAA9BF;;SAAAA,e","sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: () => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input = TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    Keyboard.dismiss();\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = null;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = null;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}